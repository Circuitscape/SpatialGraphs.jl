<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>User Guide · SpatialGraphs.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img class="docs-light-only" src="../assets/logo.svg" alt="SpatialGraphs.jl logo"/><img class="docs-dark-only" src="../assets/logo-dark.svg" alt="SpatialGraphs.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">SpatialGraphs.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">About</a></li><li><a class="tocitem" href="../graphtypes/">Graph Types</a></li><li class="is-active"><a class="tocitem" href>User Guide</a><ul class="internal"><li><a class="tocitem" href="#Building-Graphs-from-Rasters"><span>Building Graphs from Rasters</span></a></li></ul></li><li><a class="tocitem" href="../examples/">Examples</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>User Guide</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>User Guide</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/Circuitscape/SpatialGraphs.jl/blob/77dff28c078cd1b959aed77c169b0805ac2cbd3f/docs/src/userguide.md" title="View on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">View on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="User-Guide"><a class="docs-heading-anchor" href="#User-Guide">User Guide</a><a id="User-Guide-1"></a><a class="docs-heading-anchor-permalink" href="#User-Guide" title="Permalink"></a></h1><h2 id="Building-Graphs-from-Rasters"><a class="docs-heading-anchor" href="#Building-Graphs-from-Rasters">Building Graphs from Rasters</a><a id="Building-Graphs-from-Rasters-1"></a><a class="docs-heading-anchor-permalink" href="#Building-Graphs-from-Rasters" title="Permalink"></a></h2><p>SpatialGraphs.jl offers several functions for constructing graphs from raster data, which are detailed below. Once you have converted your data to an <a href="../graphtypes/#SpatialGraphs.AbstractSpatialGraph"><code>AbstractSpatialGraph</code></a>, you can analyze the graph using funtions from Graphs.jl. Following you analysis, you can then use the  spatial information stored in the <code>AbstractSpatialGraph</code> to map values  (such as betweenness or cost distance, for example) back to the appropriate  points in space. See the <a href="../examples/#Examples">Examples</a> section for a detailed  demonstration of how this can be done.</p><h3 id="Simple-Graphs"><a class="docs-heading-anchor" href="#Simple-Graphs">Simple Graphs</a><a id="Simple-Graphs-1"></a><a class="docs-heading-anchor-permalink" href="#Simple-Graphs" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="SpatialGraphs.rastergraph" href="#SpatialGraphs.rastergraph"><code>SpatialGraphs.rastergraph</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rastergraph(
    raster::Raster;
    directed::Bool = true,
    condition::Function = is_data,
    cardinal_neighbors_only::Bool = false
)</code></pre><p>Construct a <code>RasterGraph</code> or <code>RasterDiGraph</code> (if <code>directed = true</code>) from a raster dataset.</p><p><strong>Parameters</strong></p><p><code>raster</code>: A <code>Rasters.Raster</code> on which to base the graph. Any pixel in <code>raster</code>  with a value not equal to <code>raster.missingval</code> will be assigned a vertex in the graph (corresponding to its centroid). The values in the raster can also be used to determine which vertices to connect. See <code>condition</code> below for more information.</p><p><strong>Arguments</strong></p><p><code>directed</code>: A <code>Bool</code> determining whether the graph should be directed.</p><p><code>condition</code>: A function that compares the values in <code>raster</code> for two neighbors to determine if those neighbors should be connected. The function must compare two values and return either <code>true</code> or <code>false</code>. Useful functions to use  here include <code>&lt;</code>, <code>&lt;=</code>, <code>==</code>, etc. The first argument to <code>condition</code> corresponds to the source vertex, and the second argument corresponds to the destination  vertex. So, if you only want to connect sources to destinations that have a lower value in <code>raster</code> (e.g. in the case of developing a hydrologic flow  graph based on elevation), then you would use <code>&gt;</code> for <code>condition</code>. Defaults to  <code>is_data</code>, which results in neighbors being connected as long as they are not  NoData (<code>raster.missingval</code>). Note that if using an inequality function (or any function where the result depends on argument position), <code>directed</code>  should be set to <code>true</code>. For undirected graphs, you can use either <code>is_data</code> or <code>==</code>, or any other custom function where argument position doesn&#39;t matter, e.g. a function that determines whether the values in <code>raster</code> are within a certain distance of each other.</p><p><code>cardinal_neighbors_only</code>: A <code>Bool</code> stating whether only cardinal neighbors should be connected. By default, both cardinal <em>and</em> diagonal neighbors are connected. Note that this particular function does <strong>NOT</strong> account for the  increased distance between diagonal neighbors (as compared to the distance between cardinal neighbors), since for a <code>SimpleGraph</code> or <code>SimpleDiGraph</code>, all weights are effectively set to 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Circuitscape/SpatialGraphs.jl/blob/77dff28c078cd1b959aed77c169b0805ac2cbd3f/src/rastergraphs.jl#L167-L210">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpatialGraphs.make_simple_raster_graph" href="#SpatialGraphs.make_simple_raster_graph"><code>SpatialGraphs.make_simple_raster_graph</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">make_simple_raster_graph(
    raster::Raster,
    vertex_raster::Raster;
    directed::Bool = false,
    condition::Function = is_data,
    cardinal_neighbors_only::Bool = false
)</code></pre><p>Construct a <code>SimpleGraph</code> or <code>SimpleDiGraph</code> (if <code>directed = true</code>) based on  two rasters (<code>raster</code> and <code>vertex_raster</code>). This function is useful  if you already have a custom vertex raster and don&#39;t want SpatialGraphs.jl to make one for you. The vertex raster denotes the spatial locations of each vertex in the graph, and <code>raster</code> is used to construct the graph and determine which vertices to connect.</p><p><strong>Parameters</strong></p><p><code>raster</code>: A <code>Rasters.Raster</code> on which to base the graph. Any pixel in <code>raster</code>  with a value not equal to <code>raster.missingval</code> will be assigned a vertex in the graph (corresponding to its centroid). The values in the raster can also be used to determine which vertices to connect. See <code>condition</code> below for more information.</p><p><code>vertex_raster</code>: A <code>Rasters.Raster</code> with integer values ranging from 1:n,  where n is the number of unique vertices in the graph. </p><p><strong>Arguments</strong></p><p><code>directed</code>: A <code>Bool</code> determining whether the graph should be directed.</p><p><code>condition</code>: A function that compares the values in <code>raster</code> for two neighbors to determine if those neighbors should be connected. The function must compare two values and return either <code>true</code> or <code>false</code>. Useful functions to use  here include <code>&lt;</code>, <code>&lt;=</code>, <code>==</code>, etc. The first argument to <code>condition</code> corresponds to the source vertex, and the second argument corresponds to the destination  vertex. So, if you only want to connect sources to destinations with a lower value in <code>raster</code> (e.g. in the case of developing a hydrologic flow  graph based on elevation), then you would use <code>&gt;</code> for <code>condition</code>. Defaults to  <code>is_data</code>, which results in neighbors being connected as long as they are not  NoData in <code>raster</code> (<code>raster.missingval</code>). Note that if using an inequality function (or any function where the result depends on argument  position), the graph must be directed. For undirected graphs, you can use either <code>is_data</code> or <code>==</code>, or any other custom function where argument position doesn&#39;t matter, e.g. a function that determines whether the values in <code>raster</code> are within a certain distance of each other.</p><p><code>cardinal_neighbors_only</code>: A <code>Bool</code> stating whether only cardinal neighbors should be connected. By default, both cardinal <em>and</em> diagonal neighbors are connected. Note that this particular function does <strong>NOT</strong> account for the  increased distance between diagonal neighbors (as compared to the distance between cardinal neighbors), since for a <code>SimpleGraph</code> or <code>SimpleDiGraph</code>, all weights are effectively set to 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Circuitscape/SpatialGraphs.jl/blob/77dff28c078cd1b959aed77c169b0805ac2cbd3f/src/rastergraphs.jl#L342-L393">source</a></section></article><h3 id="Weighted-Graphs"><a class="docs-heading-anchor" href="#Weighted-Graphs">Weighted Graphs</a><a id="Weighted-Graphs-1"></a><a class="docs-heading-anchor-permalink" href="#Weighted-Graphs" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="SpatialGraphs.weightedrastergraph" href="#SpatialGraphs.weightedrastergraph"><code>SpatialGraphs.weightedrastergraph</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">weightedrastergraph(
    weight_raster::Raster;
    directed::Bool = false,
    condition_raster::Raster = weight_raster,
    condition::Function = is_data,
    cardinal_neighbors_only::Bool = false,
    connect_using_avg_weights::Bool = true
)</code></pre><p>Construct a <code>WeightedRasterGraph</code> or <code>WeightedRasterDiGraph</code> (if  <code>directed = true</code>) from a raster dataset. The weight raster denotes the edge weight correponding to each vertex. Since edges are between rather than on vertices, edge weights are calculated as the average of the weights for each vertex.</p><p><strong>Parameters</strong></p><p><code>weight_raster</code>: A <code>Rasters.Raster</code> containing values that, where applicable  based on other arguments, determine which pixels to connect and the edge  weights between pixels. Any pixel in <code>weight_raster</code> with a value not equal to  <code>weight_raster.missingval</code> will be assigned a vertex in the graph (corresponding to its centroid). </p><p><strong>Arguments</strong></p><p><code>directed</code>: A <code>Bool</code> determining whether the graph should be directed.</p><p><code>condition_raster</code>: A raster with values that can be used to determine whether two neighboring pixels should be connected. For example, an elevation raster  can be used to create a hydologic flow graph. Defaults to the <code>weight_raster</code>.</p><p><code>condition</code>: A function that compares the values in <code>condition_raster</code> for two neighbors to determine if those neighbors should be connected. The function must compare two values and return either <code>true</code> or <code>false</code>. Useful functions to use  here include <code>&lt;</code>, <code>&lt;=</code>, <code>==</code>, etc. The first argument to <code>condition</code> corresponds to the source vertex, and the second argument corresponds to the destination  vertex. So, if you only want to connect sources to destinations that have a  lower value in <code>condition_raster</code> (e.g. in the case of developing a hydrologic flow graph based on elevation), then you would use <code>&gt;</code> for <code>condition</code>. Defaults to <code>is_data</code>, which results in neighbors being connected as long as they are not  NoData in <code>condition_raster</code> (<code>condition_raster.missingval</code>). Note that if using an inequality function (or any function where the result depends on argument  position), <code>directed</code> should be set to <code>true</code>. For undirected graphs, you can use either <code>is_data</code> or <code>==</code>, or any other custom function where argument  position doesn&#39;t matter, e.g. a function that determines whether the values in <code>condition_raster</code> are within a certain distance of each other.</p><p><code>cardinal_neighbors_only</code>: A <code>Bool</code> stating whether only cardinal neighbors should be connected. By default, both cardinal <em>and</em> diagonal neighbors are connected. Note that when determining weights between diagonal neighbors, the increased distance between them (as compared to the distance between cardinal neighbors) is accounted for.</p><p><code>connect_using_avg_weights</code>: <code>Bool</code>. This is intended to offer methods that complement those used in Circuitscape.jl and Omniscape.jl. In this context, weights (the values in <code>weight_raster</code>) are in units of electrical resistance.  If <code>false</code>, the weight between two nodes with resistances R1 and R2 is  calculated by converting resistance to conductances, taking the average, then  taking the inverse of the result to convert back to resistance:  <code>1 / ((1/R1 + 1/R2) / 2)</code>. <code>connect_using_avg_weights = false</code> corresponds to  the default settings in Circuitscape. Defaults to <code>true</code>, in which case the  simple average (adjusted for distance in the case of diagonal  neighbors) of the weights in <code>weight_raster</code> is used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Circuitscape/SpatialGraphs.jl/blob/77dff28c078cd1b959aed77c169b0805ac2cbd3f/src/rastergraphs.jl#L74-L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpatialGraphs.make_weighted_raster_graph" href="#SpatialGraphs.make_weighted_raster_graph"><code>SpatialGraphs.make_weighted_raster_graph</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">make_weighted_raster_graph(
    weight_raster::Raster,
    vertex_raster::Raster;
    directed::Bool = false,
    condition_raster::Raster = weight_raster,
    condition::Function = is_data,
    cardinal_neighbors_only::Bool = false,
    connect_using_avg_weights::Bool = true,
    combine::Function = min
)</code></pre><p>Construct a <code>SimpleWeightedGraph</code> or <code>SimpleWeightedDiGraph</code> (if  <code>directed = true</code>) based on vertex and weight rasters. This function is useful  if you already have a custom vertex raster and don&#39;t want SpatialGraphs.jl to make one for you. The vertex raster denotes the spatial locations of each vertex in the graph, and the weight raster denotes the edge weight correponding to each vertex. Since edges are between rather than on vertices, edge weights are calculated as the average of the weights for each vertex being connected.</p><p><strong>Parameters</strong></p><p><code>weight_raster</code>: A <code>Rasters.Raster</code> containing values that, where applicable  based on other arguments, determine which pixels to connect and the edge  weights between pixels. Any pixel in <code>weight_raster</code> with a value not equal to  <code>weight_raster.missingval</code> will be assigned a vertex in the graph (corresponding to its centroid). </p><p><code>vertex_raster</code>: A <code>Rasters.Raster</code> with integer values ranging from 1:n,  where n is the number of unique vertices in the graph. </p><p><strong>Arguments</strong></p><p><code>directed</code>: A <code>Bool</code> determining whether the graph should be directed.</p><p><code>condition_raster</code>: A raster with values that can be used to determine whether two neighboring pixels should be connected. For example, an elevation raster  can be used to create a hydologic flow graph. Defaults to the <code>weight_raster</code>.</p><p><code>condition</code>: A function that compares the values in <code>condition_raster</code> for two neighbors to determine if those neighbors should be connected. The function must compare two values and return either <code>true</code> or <code>false</code>. Useful functions to use  here include <code>&lt;</code>, <code>&lt;=</code>, <code>==</code>, etc. The first argument to <code>condition</code> corresponds to the source vertex, and the second argument corresponds to the destination  vertex. So, if you only want to connect sources to destinations that have a lower value in <code>condition_raster</code> (e.g. in the case of developing a hydrologic  flow graph based on elevation), then you would use <code>&gt;</code> for <code>condition</code>. Defaults to <code>is_data</code>, which results in neighbors being connected as long as they are not  NoData in <code>condition_raster</code> (<code>condition_raster.missingval</code>). Note that if using an inequality function (or any function where the result depends on argument position), <code>directed</code> should be set to <code>true</code>. For undirected graphs, you can use either <code>is_data</code> or <code>==</code>, or any other custom function where argument position doesn&#39;t matter, e.g. a function that determines whether the values in <code>condition_raster</code> are within a certain distance of each other.</p><p><code>cardinal_neighbors_only</code>: A <code>Bool</code> stating whether only cardinal neighbors should be connected. By default, both cardinal <em>and</em> diagonal neighbors are connected. Note that when determining weights between diagonal neighbors, the increased distance between them (as compared to the distance between cardinal neighbors) is accounted for.</p><p><code>connect_using_avg_weights</code>: <code>Bool</code>. This is intended to offer methods that complement those used in Circuitscape.jl and Omniscape.jl. In this context, weights (the values in <code>weight_raster</code>) are in units of electrical resistance.  If <code>false</code>, the weight between two nodes with resistances R1 and R2 is  calculated by converting resistance to conductances, taking the average, then  taking the inverse of the result to convert back to resistance:  <code>1 / ((1/R1 + 1/R2) / 2)</code>. <code>connect_using_avg_weights = false</code> correspondes to  the default settings in Circuitscape. Defaults to <code>true</code>, in which case the  simple average (adjusted for distance in the case of diagonal  neighbors) of the weights in <code>weight_raster</code> is used.</p><p><code>combine</code>: In the case that there are multiple edges defined for a single pair of vertices, how should the weight be chosen? Defaults to <code>min</code>. See the docs for <code>SparseArrays.sparse()</code> for more information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Circuitscape/SpatialGraphs.jl/blob/77dff28c078cd1b959aed77c169b0805ac2cbd3f/src/rastergraphs.jl#L236-L309">source</a></section></article><h3 id="Making-vertex-rasters"><a class="docs-heading-anchor" href="#Making-vertex-rasters">Making vertex rasters</a><a id="Making-vertex-rasters-1"></a><a class="docs-heading-anchor-permalink" href="#Making-vertex-rasters" title="Permalink"></a></h3><p>In SpatialGraphs.jl, vertex rasters serve as the spatial reference for the  vertices in a graph. SpatialGraphs.jl provides functions to generate these rasters. Often, it is done internally and the end user doesn&#39;t need to use these functions, but there are some cases where it will be necessary. For example, it  is often the case that a user may want a single graph vertex to occupy multiple pixels in space (e.g. when modeling habitat connectivity between two protected areas). SpatialGraphs.jl enables this by offering a method for the  <code>make_vertex_raster</code> function (below) that accepts a raster representing these patches as an argument.</p><article class="docstring"><header><a class="docstring-binding" id="SpatialGraphs.make_vertex_raster" href="#SpatialGraphs.make_vertex_raster"><code>SpatialGraphs.make_vertex_raster</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">make_vertex_raster(A::Raster)</code></pre><p>Constuct a vertex raster (a raster where the value of each pixel corresponds to its ID in a graph, and 0s correspond to NoData). Returns a <code>Raster</code>.</p><p><strong>Parameters</strong></p><p><code>A</code>: The <code>Raster</code> from which a graph will be built, which is used as the reference for building the vertex raster. Pixels with NoData (<code>A.missingval</code>) are skipped (no vertex is assigned). Pixels with NoData will get a value of 0 in the vertex raster.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Circuitscape/SpatialGraphs.jl/blob/77dff28c078cd1b959aed77c169b0805ac2cbd3f/src/rastergraphs.jl#L1-L12">source</a></section><section><div><pre><code class="nohighlight hljs">make_vertex_raster(A::Raster, patches::Raster)</code></pre><p>Constuct a vertex raster (a raster where the value of each pixel corresponds to its ID in a graph, and 0s correspond to NoData). Returns a <code>Raster</code>.</p><p><strong>Parameters</strong></p><p><code>A</code>: The <code>Raster</code> from which a graph will be built, which is used as the reference for building the vertex raster. Pixels with NoData (<code>A.missingval</code>) are skipped (no vertex is assigned). Pixels with NoData will get a value of 0 in the vertex raster.</p><p><code>patches</code>: A <code>Raster</code> defining patches that may consist of multiple pixels but should be considered a single vertex in the graph. patches must have the  same dimensions a <code>A</code>. Each patch should have its own unique value, starting  with 1, and ending with n, where n is the total number of patches (e.g. if you  have 3 patches, pixels in the first patch should have a value of 1, the second patch a value of 2, and the third patch a value of 3). Non-patch pixels can  either be labeled with 0 of the raster&#39;s <code>missingval</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Circuitscape/SpatialGraphs.jl/blob/77dff28c078cd1b959aed77c169b0805ac2cbd3f/src/rastergraphs.jl#L27-L46">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../graphtypes/">« Graph Types</a><a class="docs-footer-nextpage" href="../examples/">Examples »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Thursday 13 January 2022 22:57">Thursday 13 January 2022</span>. Using Julia version 1.7.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
